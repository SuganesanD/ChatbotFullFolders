const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const { milvusClient, DataType } = require('../src/config/milvusClient');
const { GoogleGenerativeAIEmbeddings, ChatGoogleGenerativeAI } = require('@langchain/google-genai');
const fs = require('fs');
const readline = require('readline');

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;

if (!GOOGLE_API_KEY) {
    console.error("GOOGLE_API_KEY environment variable is not set. Please set it in your .env file.");
    process.exit(1);
}

// Initialize LLM for template generation (used for documentText)
const chatModel = new ChatGoogleGenerativeAI({
    apiKey: GOOGLE_API_KEY,
    model: "gemini-2.0-flash",
    temperature: 0.1,
});

// Initialize embedding model
const embeddings = new GoogleGenerativeAIEmbeddings({
    apiKey: GOOGLE_API_KEY,
    model: "embedding-001",
});

// Helper function to introduce a delay
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Function to infer Milvus DataType from JavaScript type
function inferMilvusDataType(value) {
    if (value === null) {
        // For null values, we infer VarChar and mark as nullable in schema
        return DataType.VarChar;
    }
    switch (typeof value) {
        case 'string':
            return DataType.VarChar;
        case 'number':
            // Check if the number is an integer or float
            return Number.isInteger(value) ? DataType.Int64 : DataType.Float;
        case 'boolean':
            return DataType.Bool;
        case 'object':
            // For objects (like nested JSON), stringify them to store as VarChar
            return DataType.VarChar;
        default:
            console.warn(`Unexpected JavaScript type '${typeof value}' for value:`, value, `. Defaulting to DataType.VarChar.`);
            return DataType.VarChar;
    }
}

/**
 * Generates a comprehensive JavaScript template literal string for documentText using an LLM.
 * The template will include placeholders for all relevant fields from a record,
 * excluding 'docId' (as it's auto-generated by Milvus).
 * @param {string} collectionName - The name of the current collection.
 * @param {string} collectionDescription - A brief description of the collection's purpose.
 * @param {object} fieldDescriptions - An object mapping field names to their descriptions.
 * @param {object} firstRecord - An example record to help the LLM understand context and data types.
 * @returns {Promise<{template: string|null, fieldNames: string[]}>} An object containing the approved JavaScript template literal string and an array of field names, or null if not approved.
 */
async function getApprovedDocumentTextTemplate(collectionName, collectionDescription, fieldDescriptions, firstRecord) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    let approvedTemplate = null;
    let approvedFieldNames = null;

    while (approvedTemplate === null) {
        console.log(`\n--- Generating DocumentText Template for '${collectionName}' with LLM ---`);

        // Prepare schema info for LLM, excluding docId, embedding, and documentText
        const schemaForLLM = Object.keys(fieldDescriptions)
            .filter(fieldName => fieldName !== "docId" && fieldName !== "embedding" && fieldName !== "documentText")
            .map(fieldName => ({
                name: fieldName,
                description: fieldDescriptions[fieldName] || `Field: ${fieldName}.`
            }));

        // Construct a string that lists all field names for the LLM to strictly include
        // This list is for instruction, not to be literally copied by the LLM
        const allFieldNames = schemaForLLM.map(f => f.name).join(', ');

        const llmPrompt = `You are a text formatter. Your task is to create a single, coherent, natural English paragraph as a string template for a document summary. The paragraph MUST include **EVERY SINGLE FIELD** listed in the 'Schema' section below, using the exact field names provided. Do not omit any field from the list: ${allFieldNames}. Use **double curly braces** for placeholders, like \`{{fieldName}}\`. Arrange the fields into a meaningful, readable narrative that flows naturally, avoiding a simple list-like structure. **Do NOT add any extra words, phrases, or interpretive text (e.g., 'if applicable', 'is/are', 'has/has not').** Do NOT include conditional logic (e.g., if/else, ternary operators). Do NOT modify or invent new field names. The formatting of dates, booleans, nulls, or other data types (e.g., converting Unix timestamps to dates, booleans to 'Yes'/'No', or handling nulls with 'N/A') will be handled by the application code *after* this template is filled, so include field placeholders as-is. Do not include any introductory or concluding remarks. Only return the string template forming a single paragraph.

Here is an example of the desired output style for a few fields (your output must include ALL fields from the schema and form a cohesive paragraph, not a list):
\`\`\`
Student {{studentName}} with ID {{studentId}} in grade {{studentGradeLevel}} at {{schoolName}} in {{schoolCity}}, {{schoolState}} submitted a {{leaveType}} request with ID {{leaveId}} for {{leaveReasonText}} from {{leaveStartDateUnix}} to {{leaveEndDateUnix}}.
\`\`\`

Collection Description: ${collectionDescription}

Schema (Field Names and Descriptions):
${JSON.stringify(schemaForLLM, null, 2)}

Example Record (for context on field values):
${JSON.stringify(firstRecord, null, 2)}

Generate the string template that includes all fields in a single paragraph:`;

        try {
            const response = await chatModel.invoke(llmPrompt);
            const generatedTemplate = response.content;

            console.log("\nGenerated DocumentText Template:");
            console.log("------------------------------------------");
            console.log(generatedTemplate);
            console.log("------------------------------------------");

            const answer = await new Promise(resolve => {
                rl.question("Do you approve this template? (yes/no): ", input => {
                    resolve(input.toLowerCase());
                });
            });

            if (answer === 'yes') {
                approvedTemplate = generatedTemplate;
                approvedFieldNames = schemaForLLM.map(f => f.name); // Capture field names when approved
                console.log("Template approved. Proceeding with data ingestion.");
            } else if (answer === 'no') {
                console.log("Template rejected. Regenerating a new template...");
            } else {
                console.log("Invalid input. Please type 'yes' or 'no'. Regenerating...");
            }
        } catch (error) {
            console.error("Error generating template with LLM:", error);
            console.log("Attempting to regenerate template due to error...");
        }
    }
    rl.close();
    return { template: approvedTemplate, fieldNames: approvedFieldNames };
}

/**
 * Fills a template string with values from a record, handling specific data types.
 * @param {string} template - The template string with {{fieldName}} placeholders.
 * @param {object} record - The data record containing values for the placeholders.
 * @returns {string} The filled template string.
 */
function fillTemplate(template, record) {
    let filledText = template;
    for (const key in record) {
        let value = record[key];
        // Handle Unix timestamps
        if (key.endsWith('Unix') && typeof value === 'number' && value > 0) {
            try {
                // Convert Unix timestamp (seconds) to ISO date string (YYYY-MM-DD)
                value = new Date(value * 1000).toISOString().split('T')[0];
            } catch (e) {
                // Fallback to raw value if date conversion fails
                value = record[key];
            }
        }
        // Handle boolean values
        else if (typeof value === 'boolean') {
            value = value ? 'Yes' : 'No';
        }
        // Handle null values
        else if (value === null || value === undefined) {
            value = 'N/A';
        }
        // Handle objects by stringifying them (e.g., if dynamic fields contain nested JSON)
        else if (typeof value === 'object') {
            value = JSON.stringify(value);
        }
        // Replace all occurrences of the placeholder
        filledText = filledText.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value);
    }
    return filledText;
}


/**
 * Creates and verifies a vector index on the 'embedding' field for a given collection.
 * Includes retry logic and polling to ensure the index is ready.
 * @param {object} client - The Milvus client instance.
 * @param {string} collectionName - The name of the collection to index.
 * @returns {Promise<boolean>} True if the index is successfully created and verified, throws an error otherwise.
 */
async function createAndVerifyVectorIndex(client, collectionName) {
    console.log(`Creating vector index on 'embedding' with IVF_FLAT for collection '${collectionName}'...`);
    const indexRes = await client.createIndex({
        collection_name: collectionName,
        field_name: "embedding",
        index_name: "embedding_index",
        index_type: "IVF_FLAT",
        metric_type: "COSINE",
        params: { nlist: 4 }
    });
    console.log(`Create index response for '${collectionName}':`, JSON.stringify(indexRes, null, 2));

    let attempts = 0;
    const maxAttempts = 60; // Max attempts to check index readiness
    const delayMs = 1000; // Delay between attempts
    while (attempts < maxAttempts) {
        try {
            const res = await client.describeIndex({
                collection_name: collectionName,
                index_name: "embedding_index"
            });
            // Check for success status and if index description exists
            if (res.status?.error_code === "Success" && res.index_descriptions?.[0]) {
                console.log(`Vector index on 'embedding' for '${collectionName}' is built or recognized.`);
                return true;
            }
            console.log(`Index for '${collectionName}' not ready (attempt ${attempts + 1}):`, res.status);
        } catch (error) {
            // Log specific error message if describeIndex fails
            console.log(`Attempt ${attempts + 1}: describeIndex for '${collectionName}' failed - ${error.message}`);
        }
        await sleep(delayMs);
        attempts++;
    }
    throw new Error(`Index on 'embedding' for '${collectionName}' not found or not ready after ${maxAttempts} attempts.`);
}

/**
 * Main function to ingest data dynamically into multiple Milvus collections.
 * Reads data from a structured JSON, creates/uses a database, and processes
 * each collection sequentially, including schema inference, documentText generation,
 * data insertion, and index creation.
 */

async function ingestData() {
    const MAX_PROCESS_RETRIES = 3;
    const POLLING_INTERVAL_COLLECTION_EXISTENCE_MS = 1000; // Polling interval for collection existence

    for (let processAttempt = 1; processAttempt <= MAX_PROCESS_RETRIES; processAttempt++) {
        console.log(`\n--- Overall Ingestion Attempt ${processAttempt} of ${MAX_PROCESS_RETRIES} ---`);
        try {
            console.log('Loading sample data from sampleRecordsMultiCollection.json...');
            const rawData = fs.readFileSync(path.join(__dirname, 'sampleRecordsMultiCollection.json'));
            const fullJsonData = JSON.parse(rawData);

            const databaseName = fullJsonData.databaseName;
            const collectionsToIngest = fullJsonData.collections;

            if (!databaseName) {
                console.error("No 'databaseName' found in JSON. Exiting ingestion.");
                process.exit(1);
            }
            if (!collectionsToIngest || collectionsToIngest.length === 0) {
                console.warn("No collections found in JSON or 'collections' key is missing. Exiting ingestion.");
                return;
            }

            // 1. Initialize Milvus Client & Select Database
            console.log(`\nChecking/Creating Database: '${databaseName}'...`);
            let dbExists = false;
            try {
                const listDbResponse = await milvusClient.listDatabases();
                if (listDbResponse.db_names && listDbResponse.db_names.includes(databaseName)) {
                    dbExists = true;
                }
            } catch (error) {
                console.error(`Error listing databases: ${error.message}. Assuming database does not exist for creation check.`);
            }

            if (!dbExists) {
                console.log(`Database '${databaseName}' does not exist. Creating it...`);
                const createDbResponse = await milvusClient.createDatabase({ db_name: databaseName });
                console.log(`Create database response:`, JSON.stringify(createDbResponse, null, 2));
                console.log(`Database '${databaseName}' created.`);
            } else {
                console.log(`Database '${databaseName}' already exists.`);
            }
            const useDbResponse = await milvusClient.use({ db_name: databaseName });
            console.log(`Use database response:`, JSON.stringify(useDbResponse, null, 2));
            console.log(`Switched to database: '${databaseName}'.`);

            // Store collection names and their expected row counts for final verification
            const collectionsForFinalVerification = [];

            // 2. Process Each Collection (Sequentially)
            for (const collectionData of collectionsToIngest) {
                const collectionName = collectionData.collectionName;
                const collectionDescription = collectionData.collectionDescription;
                const fieldDescriptions = collectionData.field_descriptions;
                const records = collectionData.records;

                if (!collectionName || !records || records.length === 0) {
                    console.warn(`Skipping collection due to missing name or records:`, collectionData);
                    continue;
                }

                console.log(`\n--- Processing Collection: '${collectionName}' ---`);

                const firstRecord = records[0];
                const inferredFields = [];
                const scalarIndexCandidates = [];

                // 3.b. Dynamically Define Milvus Collection Fields (Schema)
                inferredFields.push({
                    name: "docId",
                    data_type: DataType.VarChar,
                    is_primary_key: true,
                    max_length: 128,
                    auto_id: false,
                    description: fieldDescriptions.docId || "Unique identifier for each document/record."
                });
                inferredFields.push({
                    name: "embedding",
                    data_type: DataType.FloatVector,
                    dim: 768,
                    description: "The vector embedding of the document content, used for semantic search."
                });
                inferredFields.push({
                    name: "documentText",
                    data_type: DataType.VarChar,
                    max_length: 8192,
                    description: "A dynamically generated summary paragraph for each record, used for semantic search."
                });

                for (const fieldName in fieldDescriptions) {
                    if (fieldName === "docId" || fieldName === "embedding" || fieldName === "documentText") {
                        continue;
                    }

                    const description = fieldDescriptions[fieldName];
                    const value = firstRecord[fieldName];

                    let milvusDataType = inferMilvusDataType(value);
                    let fieldDefinition = {
                        name: fieldName,
                        data_type: milvusDataType,
                        description: description
                    };

                    if (milvusDataType === DataType.VarChar) {
                        fieldDefinition.max_length = 8192;
                    }
                    if (value === null || value === undefined) {
                        fieldDefinition.is_nullable = true;
                    }

                    if (!Object.values(DataType).includes(milvusDataType)) {
                        console.error(`[Schema Inference ERROR] Inferred Milvus DataType for field '${fieldName}' is invalid: ${milvusDataType}. Defaulting to DataType.VarChar.`);
                        fieldDefinition.data_type = DataType.VarChar;
                        fieldDefinition.max_length = 8192;
                    }

                    inferredFields.push(fieldDefinition);
                    if (fieldDefinition.name !== "docId" && fieldDefinition.data_type !== DataType.FloatVector) {
                        scalarIndexCandidates.push({ name: fieldName, data_type: milvusDataType });
                    }
                }

                const COLLECTION_SCHEMA = {
                    collectionName: collectionName,
                    description: collectionDescription,
                    fields: inferredFields,
                    enableDynamicField: true
                };

                // 3.c. Milvus Collection Management (Create/Drop/Load)
                let collectionSuccessfullyCreated = false;
                const MAX_COLLECTION_CREATION_ATTEMPTS = 5;
                const MAX_COLLECTION_EXISTENCE_POLLING_ATTEMPTS = 30;

                for (let createAttempt = 0; createAttempt < MAX_COLLECTION_CREATION_ATTEMPTS; createAttempt++) {
                    console.log(`\nAttempt ${createAttempt + 1} to create and verify collection '${collectionName}'...`);
                    try {
                        console.log(`Checking if collection '${collectionName}' exists in database '${databaseName}'...`);
                        const hasCollection = await milvusClient.hasCollection({ collection_name: collectionName });

                        if (hasCollection.value) {
                            console.log(`Collection '${collectionName}' already exists. Dropping it to create a fresh one.`);
                            await milvusClient.dropCollection({ collection_name: collectionName });
                            await sleep(2000);
                            console.log(`Collection '${collectionName}' dropped.`);
                        }

                        console.log(`Creating collection '${collectionName}' with dynamic schema...`);
                        console.log("Final COLLECTION_SCHEMA being sent to Milvus:", JSON.stringify(COLLECTION_SCHEMA, null, 2));
                        await milvusClient.createCollection({
                            collection_name: COLLECTION_SCHEMA.collectionName,
                            fields: COLLECTION_SCHEMA.fields,
                            description: COLLECTION_SCHEMA.description,
                            enableDynamicField: COLLECTION_SCHEMA.enableDynamicField
                        });
                        console.log(`Collection '${collectionName}' creation command sent successfully.`);
                        await sleep(2000);

                        let collectionConfirmedToExist = false;
                        for (let i = 0; i < MAX_COLLECTION_EXISTENCE_POLLING_ATTEMPTS; i++) {
                            try {
                                const checkExistence = await milvusClient.hasCollection({ collection_name: collectionName });
                                if (checkExistence.value) {
                                    console.log(`Collection '${collectionName}' confirmed to exist.`);
                                    collectionConfirmedToExist = true;
                                    break;
                                } else {
                                    console.log(`Collection '${collectionName}' not yet confirmed to exist. Retrying hasCollection... (${i + 1}/${MAX_COLLECTION_EXISTENCE_POLLING_ATTEMPTS})`);
                                }
                            } catch (checkError) {
                                console.warn(`Warning during collection existence check for '${collectionName}': ${checkError.message}. Retrying hasCollection...`);
                            }
                            await sleep(POLLING_INTERVAL_COLLECTION_EXISTENCE_MS);
                        }

                        if (collectionConfirmedToExist) {
                            collectionSuccessfullyCreated = true;
                            console.log(`Collection '${collectionName}' successfully created and verified.`);
                            break;
                        } else {
                            throw new Error(`Collection '${collectionName}' could not be confirmed to exist after creation command.`);
                        }
                    } catch (error) {
                        console.error(`Error in collection creation/verification attempt ${createAttempt + 1} for '${collectionName}': ${error.message}`);
                        if (createAttempt < MAX_COLLECTION_CREATION_ATTEMPTS - 1) {
                            console.log("Retrying collection creation after 5 seconds...");
                            await sleep(5000);
                        } else {
                            throw new Error(`Failed to create and verify collection '${collectionName}' after ${MAX_COLLECTION_CREATION_ATTEMPTS} attempts.`);
                        }
                    }
                }

                if (!collectionSuccessfullyCreated) {
                    throw new Error(`Collection '${collectionName}' creation failed after multiple attempts.`);
                }

                const { template: documentTextTemplate } = await getApprovedDocumentTextTemplate(
                    collectionName,
                    collectionDescription,
                    fieldDescriptions,
                    firstRecord
                );
                console.log(`Generated documentText template for '${collectionName}':`, documentTextTemplate);
                if (!documentTextTemplate) {
                    console.error("No approved documentText template. Exiting ingestion for this collection.");
                    throw new Error("DocumentText template generation failed.");
                }

                console.log(`Generating documentText, embeddings and inserting ${records.length} entities into '${collectionName}'...`);
                const entities = [];
                let docIdCounter = 1;

                for (const record of records) {
                    const currentDocId = record.docId || `AUTO_DOC_${docIdCounter++}`;
                    let generatedDocumentText;
                    try {
                        generatedDocumentText = fillTemplate(documentTextTemplate, record);
                    } catch (e) {
                        console.error(`Error evaluating documentText template for record:`, record, `Error:`, e.message);
                        generatedDocumentText = JSON.stringify(record);
                    }

                    const embedding = await embeddings.embedQuery(generatedDocumentText);

                    const entity = {
                        docId: currentDocId,
                        embedding: embedding,
                        documentText: generatedDocumentText
                    };

                    for (const key in record) {
                        if (key !== "docId" && key !== "documentText" && key !== "embedding") {
                            entity[key] = record[key] === null ? "" : record[key];
                        }
                    }
                    entities.push(entity);
                }

                const insertResponse = await milvusClient.insert({
                    collection_name: collectionName,
                    fields_data: entities
                });
                console.log(`Insert response for '${collectionName}':`, JSON.stringify(insertResponse, null, 2));
                if (insertResponse.status.error_code !== 'Success') {
                    throw new Error(`Insert failed for '${collectionName}': ${insertResponse.status.reason}`);
                }
                console.log(`Data ingestion complete for '${collectionName}'. ${insertResponse.insert_cnt || entities.length} entities inserted.`);

                console.log(`Flushing collection '${collectionName}' with ${records.length} records at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}...`);
                const flushResponse = await milvusClient.flushSync({ collection_names: [collectionName] });
                console.log(`FlushSync response for '${collectionName}' at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}:`, JSON.stringify(flushResponse, null, 2));

                if (flushResponse.status.error_code !== 'Success' || !flushResponse.flushed) {
                    throw new Error(`FlushSync failed for '${collectionName}': Status=${flushResponse.status.error_code}, Flushed=${flushResponse.flushed}`);
                }

                console.log(`Waiting 5 seconds after flush for '${collectionName}'...`);
                await sleep(5000);

                console.log(`Loading collection '${collectionName}' into memory...`);
                await milvusClient.loadCollection({ collection_name: collectionName });
                console.log(`Collection '${collectionName}' loaded.`);

                const stats = await milvusClient.getCollectionStatistics({ collection_name: collectionName });
                const actualRowCount = stats.stats.find(s => s.key === 'row_count')?.value;

                if (actualRowCount !== String(records.length)) {
                    console.error(`Flush incomplete for '${collectionName}': Expected ${records.length} rows, got ${actualRowCount || 'undefined'}. Attempting fallback query...`);
                    try {
                        const queryResult = await milvusClient.query({
                            collection_name: collectionName,
                            filter: "",
                            output_fields: ["docId"],
                            limit: records.length
                        });
                        console.log(`Fallback query found ${queryResult.data.length} rows in '${collectionName}'.`);
                        if (queryResult.data.length === records.length) {
                            console.log(`Data verified via query for '${collectionName}'. Proceeding.`);
                        } else {
                            throw new Error(`Flush incomplete: Expected ${records.length} rows, got ${actualRowCount || 'undefined'}, query found ${queryResult.data.length} rows.`);
                        }
                    } catch (queryError) {
                        console.error(`Fallback query failed for '${collectionName}': ${queryError.message}`);
                        throw new Error(`Flush incomplete: Expected ${records.length} rows, got ${actualRowCount || 'undefined'}. Query verification failed.`);
                    }
                }
                console.log(`Collection '${collectionName}' flushed with ${actualRowCount} rows.`);

                await createAndVerifyVectorIndex(milvusClient, collectionName);

                for (const field of scalarIndexCandidates) {
                    let indexType;
                    if (field.data_type === DataType.VarChar) {
                        indexType = "INVERTED";
                    } else if ([DataType.Int64, DataType.Float, DataType.Double, DataType.Bool].includes(field.data_type)) {
                        indexType = "BITMAP";
                    } else {
                        console.warn(`Skipping scalar index for '${field.name}' in '${collectionName}': Unsupported data type for scalar indexing.`);
                        continue;
                    }

                    console.log(`Creating scalar index on '${field.name}' in '${collectionName}' (Milvus Type: ${field.data_type}, Index: ${indexType})...`);
                    try {
                        const fieldExistsInSchema = COLLECTION_SCHEMA.fields.some(f => f.name === field.name);
                        if (!fieldExistsInSchema) {
                            console.warn(`Skipping scalar index for '${field.name}' in '${collectionName}': field not found in final collection schema.`);
                            continue;
                        }
                        await milvusClient.createIndex({
                            collection_name: collectionName,
                            field_name: field.name,
                            index_type: indexType
                        });
                        console.log(`Scalar index on '${field.name}' in '${collectionName}' created successfully.`);
                    } catch (error) {
                        console.warn(`Warning: Could not create scalar index on '${field.name}' in '${collectionName}': ${error.message}`);
                    }
                }
                console.log(`Indexes created for '${collectionName}'.`);

                collectionsForFinalVerification.push({
                    collectionName: collectionName,
                    expectedRowCount: records.length,
                });

                console.log(`--- Finished processing collection: '${collectionName}'. Moving to next collection. ---`);
            }

            // Final Verification for all Collections
            console.log("\n--- Starting Final Verification for all Collections ---");
            let allCollectionsSuccessfullyVerified = true;

            for (const collectionInfo of collectionsForFinalVerification) {
                const { collectionName, expectedRowCount } = collectionInfo;
                console.log(`\n--- Final Verification for Collection: '${collectionName}' ---`);

                try {
                    console.log(`Loading collection '${collectionName}' for final verification...`);
                    await milvusClient.loadCollectionSync({ collection_name: collectionName });
                    console.log(`Collection '${collectionName}' loaded at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}.`);

                    let rowCountVerified = false;
                    let currentAttempt = 0;
                    const maxVerifyAttempts = 10;
                    let verifyDelayMs = 2000;

                    while (!rowCountVerified && currentAttempt < maxVerifyAttempts) {
                        currentAttempt++;
                        console.log(`Verifying row count for '${collectionName}' (attempt ${currentAttempt}/${maxVerifyAttempts}) at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}...`);
                        try {
                            const stats = await milvusClient.getCollectionStatistics({ collection_name: collectionName });
                            const actualRowCount = stats.stats.find(s => s.key === 'row_count')?.value;

                            if (actualRowCount === String(expectedRowCount)) {
                                console.log(`Row count verified: ${actualRowCount} rows in '${collectionName}' at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}.`);
                                rowCountVerified = true;
                            } else {
                                console.log(`Row count verification in progress: Expected ${expectedRowCount}, got ${actualRowCount || 'undefined'} at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}. Retrying after ${verifyDelayMs}ms...`);
                                await sleep(verifyDelayMs);
                                verifyDelayMs += 2000;
                            }
                        } catch (statsError) {
                            console.warn(`Warning: Failed to get collection statistics for '${collectionName}' on attempt ${currentAttempt}: ${statsError.message} at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}.`);
                            await sleep(verifyDelayMs);
                            verifyDelayMs += 2000;
                        }
                    }

                    if (!rowCountVerified) {
                        console.warn(`Row count verification failed after ${maxVerifyAttempts} attempts for '${collectionName}': Expected ${expectedRowCount} rows at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}. Attempting query verification as fallback...`);
                        try {
                            const queryLimit = Math.min(expectedRowCount, 1000);
                            const queryResult = await milvusClient.query({
                                collection_name: collectionName,
                                filter: "",
                                output_fields: ["docId"],
                                limit: queryLimit
                            });
                            const queryRowCount = queryResult.data.length;
                            console.log(`Query verification found ${queryRowCount} rows (sampled up to ${queryLimit}) in '${collectionName}' at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}.`);

                            if (expectedRowCount <= queryLimit && queryRowCount === expectedRowCount) {
                                console.log(`Data verified via query for '${collectionName}' at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}.`);
                                rowCountVerified = true;
                            } else if (expectedRowCount > queryLimit && queryRowCount === queryLimit) {
                                console.log(`Partial data verified via query (sampled ${queryLimit} rows) for '${collectionName}' at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}. Assuming flush complete due to large dataset.`);
                                rowCountVerified = true;
                            } else {
                                throw new Error(`Final verification failed for '${collectionName}': Expected ${expectedRowCount} rows, query found ${queryRowCount} rows.`);
                            }
                        } catch (queryError) {
                            console.warn(`Warning: Query verification failed for '${collectionName}': ${queryError.message} at ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}.`);
                            throw new Error(`Final verification failed for '${collectionName}': Expected ${expectedRowCount} rows, query failed.`);
                        }
                    }

                    if (!rowCountVerified) {
                        throw new Error(`Collection '${collectionName}' failed final data verification.`);
                    }

                    console.log(`--- Final Verification for '${collectionName}' Completed. Releasing collection... ---`);
                    await milvusClient.releaseCollection({ collection_name: collectionName });
                    console.log(`Collection '${collectionName}' released.`);

                } catch (error) {
                    console.error(`\n--- Final Verification for '${collectionName}' Failed ---`);
                    console.error(error.message);
                    allCollectionsSuccessfullyVerified = false;
                }
            }

            if (!allCollectionsSuccessfullyVerified) {
                throw new Error("One or more collections failed final verification. Check logs for details.");
            }

            console.log("\n--- All collections ingested and verified successfully! ---");
            return;

        } catch (error) {
            console.error(`\n--- Overall Ingestion Attempt ${processAttempt} Failed ---`);
            console.error(error.message);
            if (processAttempt < MAX_PROCESS_RETRIES) {
                console.log(`Retrying full ingestion process in 15 seconds...`);
                await sleep(15000);
            } else {
                console.error("All ingestion attempts failed. Please check Milvus logs and configuration.");
                process.exit(1);
            }
        }
    }
}

ingestData();